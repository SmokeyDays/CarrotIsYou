我们要干的活大概可以拆分成 **代码** / **驱动** / **接口** / **CPU** 四个部分

代码：
- 完成完整的游戏逻辑的编写，并转成 risk-v 汇编语句
- 这里的变量定义似乎全部使用局部变量会比较好，这样就能全部放在栈空间了
- 最终的汇编语句采用硬编码到 verilog 代码的形式完成加载
    - 调研结果也允许用别的方式，比如 USB-UART Bridge，但是会麻烦很多

驱动：
- 各 I/O 设备对应的中断子程序，需要用 risk-v 汇编语句编写
- 需要硬编码到 verilog 代码，并且完成与中断逻辑的相关连接
- 在接收到 I/O 设备信号的时候，要能够发出中断请求

接口：
- verilog 实现，是处理连在板子上的 I/O 设备的中枢
- 对于 input 信号，需要正确理解数据，加工处理，并与驱动交互
- 对于 output 信号，需要把待发送的数据正确加工成 I/O 设备能够识别的形式

CPU：
- verilog 实现，完整支持 risk-v 指令集，能够运行代码
- 能够正确识别和处理中断，运行驱动子程序

*物件像素图：
- 仔细思考了一下，加了一个部分
- 如果我们自己凭空造，取决于游戏复原程度，可能也会是一个不小的工作量

其中，关于 **图像显示&储存** / **比特流加载** / **供电方式** / **游戏设备** 的部分，我们可以有多种实现选择

图像显示&存储
- 待解决的问题有：不操作时画面呈现动态还是静态，操作时是否有主控物件移动中的帧，画面的像素尺寸有多高
- 关于画面像素尺寸大小：如果小的话，直接在 verilog 实现的存储结构里就能存的下，如果大的话需要与 DDR2 SDRAM 进行交互，后者有 128MiB，详见 NEXY4DDR.md
    - 另一个相关方案是，在代码部分每个物件用单像素点实现，而在 verilog 硬编码书写每个物体的形状颜色信息，最后在 VGA 显示的部分结合映射得到高像素
    - 不过 VGA 部分的映射总是要写的，比如把 1 个像素变成 1 个正方形，普通显示屏像素尺寸都太大了x
- 关于操作时是否有主控物件移动中的帧：如果有的话，在小画面方案下还好，在单像素点转高像素的方案下，可能需要做一些细节处理
- 关于不操作时画面呈现动态还是静态：图像硬编码的工作量翻两三倍

比特流加载
- 见 NEXY4DDR.md 的 Configuration Way
- 最终代码完成后可以用 SPI 端口传输写死，很方便
- 可以玩玩 USB 和 MicroSDCard 的方案，炫酷而且不贵

供电方式
- 见 NEXY4DDR.md 的 Component/Jumper/JP3
- 可以玩玩外部电源和外部电池组的方案，完全可行，同样很炫酷，同样都不贵

游戏设备
- 标准答案是键盘
- 但是！刷到了超级心动的组件 https://www.instructables.com/How-to-Use-the-PmodJSTK-With-the-Basys3-FPGA/ ，看起来超级炫酷，而且超级不贵！